# -*- coding: utf-8 -*-
"""DVP LAB

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/17VLdHflLcTeI_EVwBSEiwbti9eNjz3qD
"""

import numpy as np
rainfall_data= [120, 85, 90, 110, 95, 100, 105, 85, 115, 130, 125, 140]
rainfall_array=np.array(rainfall_data)
print(rainfall_array)

first_quater=rainfall_array[:3]
print(first_quater)

jully_rainfall=rainfall_array[6]
print(jully_rainfall)

quarters = np.split(rainfall_array, 4)

for i, quarter in enumerate(quarters, start=0):
    print(f"Quarter {i}: {quarter}")

quarters = np.split(rainfall_array, 4)

for i, quarter in enumerate(quarters, start=0):
    total_rainfall = np.sum(quarter)
    max_rainfall = np.max(quarter)
    max_rainfall_month = np.argmax(quarter) + 1
    print(f"Quarter {i}: Total Rainfall = {total_rainfall}, Highest Rainfall = {max_rainfall} (Month {max_rainfall_month})")

"""1.a:Basic NumPy Array Operations

"""

#Create a NumPy array from the given dataset.
data=[
    [85,92,78,90],
    [88,79,85,93],
    [91,85,87,88],
    [76,88,84,91]
]
scores_array=np.array(data)
print(scores_array)

#Retrieve the attributes of the array (shape, size, dtype).
shape=scores_array.shape
size=scores_array.size
dtype=scores_array.dtype
print(f"shape:{shape},\nsize:{size},\ndytype:{dtype}")

#Slice the array to get the scores of the first two students.
first_two_students=scores_array[:2, :]
print(first_two_students)

#Index the array to get the score of the second student in Chemistry.
chemistry_scores=scores_array[1,1]
print(chemistry_scores)

"""1.b: Basic NumPy Array Operations"""

#Create a NumPy array from the sales revenue list.
import numpy as np
months = ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December']
sales_revenue = [12000, 15000, 17000, 13000, 16000, 18000, 20000, 19000, 17500, 16000, 15000, 16500]
sales_revenue_array = np.array(sales_revenue)
print(sales_revenue_array)

#Retrieve the attributes of the array (shape, size, dtype).
shape=sales_revenue_array.shape
size=sales_revenue_array.size
dtype=sales_revenue_array.dtype
print(f"shape:{shape},size:{size},dtype:{dtype}")

#Slice the array to get the sales revenue for the first half of the year.
first_half_revenue=sales_revenue_array[:6]
print(first_half_revenue)

#Index the array to get the sales revenue for May.
may_revenue=sales_revenue_array[4]
print(may_revenue)

#Calculate the total sales revenue for the year
total_revenue=np.sum(sales_revenue_array)
print(total_revenue)

#Find the month with the highest sales revenue. Expected Output: Shape: (12,) Size: 12 Data type: int32 First half of the year sales revenue: [12000 15000 17000 13000 16000 18000] Sales revenue for May: 16000 Total sales revenue for the year: 195500 Month with highest sales revenue: July
max_sales_index = sales_revenue_array.argmax()
month_with_highest_sales = months[max_sales_index]
print("Month with highest sales revenue:", month_with_highest_sales)

"""1.c: Universal Functions"""

#Create NumPy Arrays for Each Performance Metric
import numpy as np
performance_data = {
    'running_speed': [10.5, 9.8, 11.2, 10.0, 9.7],
    'jump_height': [2.1, 2.3, 2.0, 2.4, 2.2],
    'throw_distance': [60.5, 62.0, 59.8, 61.2, 63.5]
}
running_speed = np.array(performance_data['running_speed'])
jump_height = np.array(performance_data['jump_height'])
throw_distance = np.array(performance_data['throw_distance'])
print("Running Speed Array:", running_speed)
print("Jump Height Array:", jump_height)
print("Throw Distance Array:", throw_distance)

#Calculate the square of the running speeds using a universal function.
running_speed = np.array(performance_data['running_speed'])
squared_running_speed = np.square(running_speed)
print("Squared Running Speeds:", squared_running_speed)

#Normalize the Jump Heights.
mean_jump_height = np.mean(jump_height)
std_jump_height = np.std(jump_height)

normalized_jump_height = (jump_height - mean_jump_height) / std_jump_height
print("Normalized Jump Heights:", normalized_jump_height)

#Apply the Exponential Function to the Throw Distances.
exponential_throw_distance = np.exp(throw_distance)
print("Exponential Throw Distances:", exponential_throw_distance)

#Calculate the Logarithm of the Normalized Jump Heights.
if np.all(normalized_jump_height > 0):
    log_normalized_jump_height = np.log(normalized_jump_height)
    print("Logarithm of Normalized Jump Heights:", log_normalized_jump_height)
else:
    print("Normalized Jump Heights contain non-positive values, cannot compute logarithm.")

#Apply the Sine Function to the Running Speeds.
sine_running_speed = np.sin(running_speed)
print("Sine of Running Speeds:", sine_running_speed)

"""1.d: Aggregate Functions"""

#Import NumPy and Create Arrays.
import numpy as np
returns_data = {
    'portfolio_A': [0.05, 0.02, 0.04, 0.03, 0.06, 0.01],
    'portfolio_B': [0.04, 0.03, 0.05, 0.02, 0.01, 0.04],
    'portfolio_C': [0.03, 0.01, 0.02, 0.03, 0.04, 0.05]
}

returns_A = np.array(returns_data['portfolio_A'])
returns_B = np.array(returns_data['portfolio_B'])
returns_C = np.array(returns_data['portfolio_C'])
print("Returns for portfolio A:", returns_A)
print("Returns for portfolio B:", returns_B)
print("Returns for portfolio C:", returns_C)

# Calculate Total Return for Each Portfolio.
total_return_A = np.sum(returns_A)
total_return_B = np.sum(returns_B)
total_return_C = np.sum(returns_C)

print(f"Total return for portfolio A: {total_return_A:.4f}")
print(f"Total return for portfolio B: {total_return_B:.4f}")
print(f"Total return for portfolio C: {total_return_C:.4f}")

#Calculate Mean Monthly Return for Each Portfolio.
mean_return_A = np.mean(returns_A)
mean_return_B = np.mean(returns_B)
mean_return_C = np.mean(returns_C)

print(f"Mean monthly return for portfolio A: {mean_return_A:.4f}")
print(f"Mean monthly return for portfolio B: {mean_return_B:.4f}")
print(f"Mean monthly return for portfolio C: {mean_return_C:.4f}")

# Find the Portfolio with the Highest Mean Return.
mean_returns = {
    'portfolio_A': mean_return_A,
    'portfolio_B': mean_return_B,
    'portfolio_C': mean_return_C
}

best_portfolio = max(mean_returns, key=mean_returns.get)
print(f"The portfolio with the highest mean return is {best_portfolio}")

# Calculate the Overall Average Return Across All Portfolios.
all_returns = np.concatenate([returns_A, returns_B, returns_C])
overall_average_return = np.mean(all_returns)
print(f"Overall average return across all portfolios: {overall_average_return:.4f}")

# Determine the Variance and Standard Deviation for Each Portfolio.
variance_A = np.var(returns_A)
std_dev_A = np.std(returns_A)

variance_B = np.var(returns_B)
std_dev_B = np.std(returns_B)

variance_C = np.var(returns_C)
std_dev_C = np.std(returns_C)

print(f"Variance and standard deviation for portfolio A: {variance_A:.4f}, {std_dev_A:.4f}")
print(f"Variance and standard deviation for portfolio B: {variance_B:.4f}, {std_dev_B:.4f}")
print(f"Variance and standard deviation for portfolio C: {variance_C:.4f}, {std_dev_C:.4f}")

"""Exercise 2.a: Analyzing Restaurant Performance"""

import numpy as np
import pandas as pd

data = [(601, 12000, 8000, np.nan),
        (602, 15000, 13000, 14000),
        (603, 16000, np.nan, 12000),
        (602, 15000, 13000, 14000),
        (604, 11000, np.nan, 9000),
        (601, 12000, 8000, np.nan)]

data_array = np.array(data)
df = pd.DataFrame(data_array, columns=['Branch ID', 'Food Sales', 'Beverage Sales', 'Dessert Sales'])
missing_values = df.isnull().sum()
duplicates = df.duplicated(subset='Branch ID', keep='first').sum()
medians = df.median()
df.fillna(medians, inplace=True)
df.drop_duplicates(subset='Branch ID', keep='first', inplace=True)
def min_max_normalize(column):
    return (column - column.min()) / (column.max() - column.min())
normalized_df = df.copy()
normalized_df[['Food Sales', 'Beverage Sales', 'Dessert Sales']] = df[['Food Sales', 'Beverage Sales', 'Dessert Sales']].apply(min_max_normalize)
normalized_stats = normalized_df[['Food Sales', 'Beverage Sales', 'Dessert Sales']].agg(['mean', 'median', 'std'])
highest_variability_category = normalized_stats.loc['std'].idxmax()
{
    "missing_values": missing_values,
    "duplicates": duplicates,
    "normalized_stats": normalized_stats,
    "highest_variability_category": highest_variability_category
}

"""2b Analysis of Credit Card Expenditure"""

import numpy as np

data = np.array([
    [401, 2000, 15],
    [402, 2500, 18],
    [403, np.nan, 20],
    [404, 2700, 22],
    [405, 2000, 15],
    [406, 2000, np.nan],
    [407, 3200, 25],
    [408, 2500, 18],
    [409, 2800, np.nan],
    [401, 2000, 15]
])


median_spending = np.nanmedian(data[:, 1])
median_transactions = np.nanmedian(data[:, 2])


data[np.isnan(data[:, 1]), 1] = median_spending
data[np.isnan(data[:, 2]), 2] = median_transactions


_, unique_indices = np.unique(data[:, 0], return_index=True)
data = data[sorted(unique_indices)]

min_spending, max_spending = np.min(data[:, 1]), np.max(data[:, 1])
min_transactions, max_transactions = np.min(data[:, 2]), np.max(data[:, 2])

data[:, 1] = (data[:, 1] - min_spending) / (max_spending - min_spending)
data[:, 2] = (data[:, 2] - min_transactions) / (max_transactions - min_transactions)

mean_spending = np.mean(data[:, 1])
median_spending = np.median(data[:, 1])
std_spending = np.std(data[:, 1])
mean_transactions = np.mean(data[:, 2])
median_transactions = np.median(data[:, 2])
std_transactions = np.std(data[:, 2])

correlation = np.corrcoef(data[:, 1], data[:, 2])[0, 1]

print("Processed Data:")
print(data)
print("\nDescriptive Statistics:")
print(f"Monthly Spending - Mean: {mean_spending}, Median: {median_spending}, Std Dev: {std_spending}")
print(f"Number of Transactions - Mean: {mean_transactions}, Median: {median_transactions}, Std Dev: {std_transactions}")
print(f"\nCorrelation between Monthly Spending and Number of Transactions: {correlation}")